import { PageData, PageFrontmatter, HeadConfig, SiteData } from '@vuepress/shared';
export { PageData, PageFrontmatter, PageHeader, SiteData } from '@vuepress/shared';
import * as vue from 'vue';
import { ComputedRef, InjectionKey, Ref, Component, App, ComponentOptions, HTMLAttributes, FunctionalComponent, VNode } from 'vue';
import { Router } from 'vue-router';
export { useRoute, useRouter } from 'vue-router';
export { C as CreateVueAppFunction } from './createVueAppFunction-YNGNKfE3.js';

/**
 * Ref wrapper of `Layouts`
 */
type LayoutsRef = ComputedRef<Layouts>;
/**
 * Injection key for layouts
 */
declare const layoutsSymbol: InjectionKey<LayoutsRef>;
/**
 * Returns layouts component map
 */
declare const useLayouts: () => LayoutsRef;

/**
 * Ref wrapper of `PageData`
 */
type PageDataRef<T extends Record<any, any> = Record<never, never>> = Ref<PageData<T>>;
/**
 * Injection key for page data
 */
declare const pageDataSymbol: InjectionKey<PageDataRef>;
/**
 * Returns the ref of the data of current page
 */
declare const usePageData: <T extends Record<any, any> = Record<never, never>>() => PageDataRef<T>;

/**
 * Ref wrapper of `PageFrontmatter`
 */
type PageFrontmatterRef<T extends Record<any, any> = Record<string, unknown>> = ComputedRef<PageFrontmatter<T>>;
/**
 * Injection key for page frontmatter
 */
declare const pageFrontmatterSymbol: InjectionKey<PageFrontmatterRef>;
/**
 * Returns the ref of the frontmatter of current page
 */
declare const usePageFrontmatter: <T extends Record<any, any> = Record<string, unknown>>() => PageFrontmatterRef<T>;

/**
 * Page head config, which would be used for generate html tags in `<head>`
 */
type PageHead = HeadConfig[];
/**
 * Ref wrapper of `PageHead`
 */
type PageHeadRef = ComputedRef<PageHead>;
/**
 * Injection key for page head
 */
declare const pageHeadSymbol: InjectionKey<PageHeadRef>;
/**
 * Returns the ref of the head config of current page
 */
declare const usePageHead: () => PageHeadRef;

/**
 * Page head title, which would be used as the content of `head > title` tag
 */
type PageHeadTitle = string;
/**
 * Ref wrapper of `PageHeadTitle`
 */
type PageHeadTitleRef = ComputedRef<PageHeadTitle>;
/**
 * Injection key for page head title
 */
declare const pageHeadTitleSymbol: InjectionKey<PageHeadTitleRef>;
/**
 * Returns the ref of the head title of current page
 */
declare const usePageHeadTitle: () => PageHeadTitleRef;

/**
 * Page language
 */
type PageLang = string;
/**
 * Ref wrapper of `PageLang`
 */
type PageLangRef = ComputedRef<PageLang>;
/**
 * Injection key for page language
 */
declare const pageLangSymbol: InjectionKey<PageLangRef>;
/**
 * Returns the ref of the language of current page
 */
declare const usePageLang: () => PageLangRef;

/**
 * Ref wrapper of `PageLayout`
 */
type PageLayoutRef = ComputedRef<Component>;
/**
 * Injection key for page layout
 */
declare const pageLayoutSymbol: InjectionKey<PageLayoutRef>;
/**
 * Returns layout component of current page
 */
declare const usePageLayout: () => ComputedRef<Component>;

/**
 * Route locale path
 */
type RouteLocale = string;
/**
 * Ref wrapper of `RouteLocale`
 */
type RouteLocaleRef = Readonly<Ref<RouteLocale>>;
/**
 * Injection key for page route locale path
 */
declare const routeLocaleSymbol: InjectionKey<RouteLocaleRef>;
/**
 * Returns the ref of the route locale path of current page
 */
declare const useRouteLocale: () => RouteLocaleRef;

interface ResolvedRoute<T extends RouteMeta = RouteMeta> extends Route<T> {
    path: string;
    notFound: boolean;
}
/**
 * Resolve route with given path
 */
declare const resolveRoute: <T extends RouteMeta = RouteMeta>(path: string) => ResolvedRoute<T>;

/**
 * Resolve route path with given raw path
 */
declare const resolveRoutePath: (path: string) => string;

/**
 * Global redirects ref
 */
declare const redirects: Ref<Redirects>;
/**
 * Global routes ref
 */
declare const routes: Ref<Routes>;

/**
 * Returns the ref of pages map
 */
declare const useRedirects: () => typeof redirects;
/**
 * Returns the ref of routes map
 */
declare const useRoutes: () => typeof routes;

/**
 * Ref wrapper of `SiteData`
 */
type SiteDataRef = Ref<SiteData>;
/**
 * Global site data ref
 */
declare const siteData: SiteDataRef;
/**
 * Returns the ref of the site data
 */
declare const useSiteData: () => SiteDataRef;

/**
 * Site data of current locale
 */
type SiteLocaleData = SiteData;
/**
 * Ref wrapper of `SiteLocaleData`
 */
type SiteLocaleDataRef = ComputedRef<SiteLocaleData>;
/**
 * Injection key for site locale data
 */
declare const siteLocaleDataSymbol: InjectionKey<SiteLocaleDataRef>;
/**
 * Returns the ref of the site data of current locale
 */
declare const useSiteLocaleData: () => SiteLocaleDataRef;

/**
 * A util function to force update `<head>` of current page
 */
type UpdateHead = () => void;
/**
 * Injection key for `updateHead` util
 */
declare const updateHeadSymbol: InjectionKey<UpdateHead>;
/**
 * Returns the `updateHead` util
 */
declare const useUpdateHead: () => UpdateHead;

type Layouts = Record<string, Component>;

/**
 * Configure vuepress client
 */
interface ClientConfig {
    /**
     * An enhance function to be called after vue app instance and
     * vue-router instance has been created
     */
    enhance?: (context: {
        app: App;
        router: Router;
        siteData: SiteDataRef;
    }) => void | Promise<void>;
    /**
     * A function to be called inside the setup function of vue app
     */
    setup?: () => void;
    /**
     * Layout components
     */
    layouts?: Layouts;
    /**
     * Components to be placed directly into the root node of vue app
     */
    rootComponents?: Component[];
}

interface PageChunk {
    comp: ComponentOptions;
    data: PageData;
}
type RouteMeta = Record<string, unknown>;
interface Route<T extends RouteMeta = RouteMeta> {
    loader: () => Promise<PageChunk>;
    meta: T;
}
type Redirects = Record<string, string>;
type Routes = Record<string, Route>;

/**
 * Wrapper component that only renders its content on the client side and skips server side rendering
 */
declare const ClientOnly: vue.DefineComponent<{}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[] | null | undefined, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{}>>, {}, {}>;

/**
 * Markdown rendered content
 */
declare const Content: vue.DefineComponent<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}>>, {
    path: string;
}, {}>;

interface RouteLinkProps extends HTMLAttributes {
    /**
     * Whether the link is active to have an active class
     *
     * Notice that the active status is not automatically determined according to the current route.
     *
     * @default false
     */
    active?: boolean;
    /**
     * The class to add when the link is active
     *
     * @default 'route-link-active'
     */
    activeClass?: string;
    /**
     * The route path to link to
     */
    to: string;
}
/**
 * Component to render a link to another route.
 *
 * It's similar to `RouterLink` in `vue-router`, but more lightweight.
 *
 * It's recommended to use `RouteLink` in VuePress.
 */
declare const RouteLink: FunctionalComponent<RouteLinkProps, Record<never, never>, {
    default: () => string | VNode | (string | VNode)[];
}>;

/**
 * A helper function to help you define vuepress client config file
 */
declare const defineClientConfig: (clientConfig?: ClientConfig) => ClientConfig;

/**
 * Prefix url with site base
 */
declare const withBase: (url: string) => string;

/**
 * Resolver methods to get global computed
 *
 * Users can override corresponding method for advanced customization
 *
 * @experimental - This is an experimental API and may be changed in minor versions
 */
declare const resolvers: {
    resolveLayouts: (clientConfigs: ClientConfig[]) => Layouts;
    resolvePageFrontmatter: (pageData: PageData) => PageFrontmatter;
    resolvePageHead: (headTitle: PageHeadTitle, frontmatter: PageFrontmatter, siteLocale: SiteLocaleData) => PageHead;
    resolvePageHeadTitle: (page: PageData, siteLocale: SiteLocaleData) => PageHeadTitle;
    resolvePageLang: (page: PageData, siteLocale: SiteLocaleData) => PageLang;
    resolvePageLayout: (page: PageData, layouts: Layouts) => Component;
    resolveRouteLocale: (locales: SiteData['locales'], routePath: string) => RouteLocale;
    resolveSiteLocaleData: (site: SiteData, routeLocale: RouteLocale) => SiteLocaleData;
};

export { type ClientConfig, ClientOnly, Content, type Layouts, type LayoutsRef, type PageChunk, type PageDataRef, type PageFrontmatterRef, type PageHead, type PageHeadRef, type PageHeadTitle, type PageHeadTitleRef, type PageLang, type PageLangRef, type PageLayoutRef, type Redirects, type Route, RouteLink, type RouteLinkProps, type RouteLocale, type RouteLocaleRef, type RouteMeta, type Routes, type SiteDataRef, type SiteLocaleData, type SiteLocaleDataRef, type UpdateHead, defineClientConfig, layoutsSymbol, pageDataSymbol, pageFrontmatterSymbol, pageHeadSymbol, pageHeadTitleSymbol, pageLangSymbol, pageLayoutSymbol, redirects, resolveRoute, resolveRoutePath, resolvers, routeLocaleSymbol, routes, siteData, siteLocaleDataSymbol, updateHeadSymbol, useLayouts, usePageData, usePageFrontmatter, usePageHead, usePageHeadTitle, usePageLang, usePageLayout, useRedirects, useRouteLocale, useRoutes, useSiteData, useSiteLocaleData, useUpdateHead, withBase };
