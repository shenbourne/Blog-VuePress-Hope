// src/composables/layouts.ts
import { inject } from "vue";
var layoutsSymbol = Symbol(
  __VUEPRESS_DEV__ ? "layouts" : ""
);
var useLayouts = () => {
  const layouts = inject(layoutsSymbol);
  if (!layouts) {
    throw new Error("useLayouts() is called without provider.");
  }
  return layouts;
};

// src/composables/pageData.ts
import { inject as inject2 } from "vue";
var pageDataSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageData" : ""
);
var usePageData = () => {
  const pageData = inject2(pageDataSymbol);
  if (!pageData) {
    throw new Error("pageData() is called without provider.");
  }
  return pageData;
};

// src/composables/pageFrontmatter.ts
import { inject as inject3 } from "vue";
var pageFrontmatterSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageFrontmatter" : ""
);
var usePageFrontmatter = () => {
  const pageFrontmatter = inject3(pageFrontmatterSymbol);
  if (!pageFrontmatter) {
    throw new Error("usePageFrontmatter() is called without provider.");
  }
  return pageFrontmatter;
};

// src/composables/pageHead.ts
import { inject as inject4 } from "vue";
var pageHeadSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageHead" : ""
);
var usePageHead = () => {
  const pageHead = inject4(pageHeadSymbol);
  if (!pageHead) {
    throw new Error("usePageHead() is called without provider.");
  }
  return pageHead;
};

// src/composables/pageHeadTitle.ts
import { inject as inject5 } from "vue";
var pageHeadTitleSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageHeadTitle" : ""
);
var usePageHeadTitle = () => {
  const pageHeadTitle = inject5(pageHeadTitleSymbol);
  if (!pageHeadTitle) {
    throw new Error("usePageHeadTitle() is called without provider.");
  }
  return pageHeadTitle;
};

// src/composables/pageLang.ts
import { inject as inject6 } from "vue";
var pageLangSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageLang" : ""
);
var usePageLang = () => {
  const pageLang = inject6(pageLangSymbol);
  if (!pageLang) {
    throw new Error("usePageLang() is called without provider.");
  }
  return pageLang;
};

// src/composables/pageLayout.ts
import { inject as inject7 } from "vue";
var pageLayoutSymbol = Symbol(
  __VUEPRESS_DEV__ ? "pageLayout" : ""
);
var usePageLayout = () => {
  const pageLayout = inject7(pageLayoutSymbol);
  if (!pageLayout) {
    throw new Error("usePageLayout() is called without provider.");
  }
  return pageLayout;
};

// src/composables/routeLocale.ts
import { inject as inject8 } from "vue";
var routeLocaleSymbol = Symbol(
  __VUEPRESS_DEV__ ? "routeLocale" : ""
);
var useRouteLocale = () => {
  const routeLocale = inject8(routeLocaleSymbol);
  if (!routeLocale) {
    throw new Error("useRouteLocale() is called without provider.");
  }
  return routeLocale;
};

// src/router/routes.ts
import {
  redirects as redirectsRaw,
  routes as routesRaw
} from "@internal/routes";
import { shallowRef } from "vue";
var redirects = shallowRef(redirectsRaw);
var routes = shallowRef(routesRaw);
if (__VUEPRESS_DEV__ && (import.meta.webpackHot || import.meta.hot)) {
  __VUE_HMR_RUNTIME__.updateRedirects = (data) => {
    redirects.value = data;
  };
  __VUE_HMR_RUNTIME__.updateRoutes = (data) => {
    routes.value = data;
  };
}

// src/router/resolveRoutePath.ts
import { normalizeRoutePath } from "@vuepress/shared";
var resolveRoutePath = (path) => {
  const normalizedPath = normalizeRoutePath(path);
  if (routes.value[normalizedPath])
    return normalizedPath;
  const encodedPath = encodeURI(normalizedPath);
  if (routes.value[encodedPath])
    return encodedPath;
  return redirects.value[normalizedPath] || normalizedPath;
};

// src/router/resolveRoute.ts
var resolveRoute = (path) => {
  const routePath = resolveRoutePath(path);
  const route = routes.value[routePath] ?? {
    ...routes.value["/404.html"],
    notFound: true
  };
  return {
    path: routePath,
    notFound: false,
    ...route
  };
};

// src/router/index.ts
import { useRoute, useRouter } from "vue-router";

// src/composables/routes.ts
var useRedirects = () => redirects;
var useRoutes = () => routes;

// src/composables/siteData.ts
import { siteData as siteDataRaw } from "@internal/siteData";
import { shallowRef as shallowRef2 } from "vue";
var siteData = shallowRef2(siteDataRaw);
var useSiteData = () => siteData;
if (__VUEPRESS_DEV__ && (import.meta.webpackHot || import.meta.hot)) {
  __VUE_HMR_RUNTIME__.updateSiteData = (data) => {
    siteData.value = data;
  };
}

// src/composables/siteLocaleData.ts
import { inject as inject9 } from "vue";
var siteLocaleDataSymbol = Symbol(
  __VUEPRESS_DEV__ ? "siteLocaleData" : ""
);
var useSiteLocaleData = () => {
  const siteLocaleData = inject9(siteLocaleDataSymbol);
  if (!siteLocaleData) {
    throw new Error("useSiteLocaleData() is called without provider.");
  }
  return siteLocaleData;
};

// src/composables/updateHead.ts
import { inject as inject10 } from "vue";
var updateHeadSymbol = Symbol(
  __VUEPRESS_DEV__ ? "updateHead" : ""
);
var useUpdateHead = () => {
  const updateHead = inject10(updateHeadSymbol);
  if (!updateHead) {
    throw new Error("useUpdateHead() is called without provider.");
  }
  return updateHead;
};

// src/components/ClientOnly.ts
import { defineComponent, onMounted, ref } from "vue";
var ClientOnly = defineComponent({
  name: "ClientOnly",
  setup(_, ctx) {
    const isMounted = ref(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return () => isMounted.value ? ctx.slots.default?.() : null;
  }
});

// src/components/Content.ts
import { computed, defineAsyncComponent, defineComponent as defineComponent2, h } from "vue";
var Content = defineComponent2({
  // eslint-disable-next-line vue/no-reserved-component-names
  name: "Content",
  props: {
    path: {
      type: String,
      required: false,
      default: ""
    }
  },
  setup(props) {
    const pageData = usePageData();
    const pageComponent = computed(() => {
      const route = resolveRoute(props.path || pageData.value.path);
      return defineAsyncComponent(() => route.loader().then(({ comp }) => comp));
    });
    return () => h(pageComponent.value);
  }
});

// src/helpers/defineClientConfig.ts
var defineClientConfig = (clientConfig = {}) => clientConfig;

// src/helpers/withBase.ts
import { isLinkHttp, removeLeadingSlash } from "@vuepress/shared";
var withBase = (url) => {
  if (isLinkHttp(url))
    return url;
  return `${__VUEPRESS_BASE__}${removeLeadingSlash(url)}`;
};

// src/components/RouteLink.ts
import { h as h2 } from "vue";
import { useRouter as useRouter2 } from "vue-router";
var guardEvent = (event) => {
  if (event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    return;
  if (event.defaultPrevented)
    return;
  if (event.button !== void 0 && event.button !== 0)
    return;
  if (event.currentTarget) {
    const target = event.currentTarget.getAttribute("target");
    if (target?.match(/\b_blank\b/i))
      return;
  }
  event.preventDefault();
  return true;
};
var RouteLink = ({ active = false, activeClass = "route-link-active", to, ...attrs }, { slots }) => {
  const router = useRouter2();
  const path = withBase(resolveRoutePath(to));
  return h2(
    "a",
    {
      ...attrs,
      class: ["route-link", { [activeClass]: active }],
      href: path,
      onClick: (event = {}) => {
        guardEvent(event) ? router.push(to).catch() : Promise.resolve();
      }
    },
    slots.default?.()
  );
};
RouteLink.displayName = "RouteLink";
RouteLink.props = {
  active: Boolean,
  activeClass: String,
  to: String
};

// src/resolvers.ts
import { dedupeHead, isString, resolveLocalePath } from "@vuepress/shared";
import { reactive } from "vue";

// src/constants.ts
var LAYOUT_NAME_DEFAULT = "Layout";
var LAYOUT_NAME_NOT_FOUND = "NotFound";

// src/resolvers.ts
var resolvers = reactive({
  /**
   * Resolve layouts component map
   */
  resolveLayouts: (clientConfigs) => clientConfigs.reduce(
    (prev, item) => ({
      ...prev,
      ...item.layouts
    }),
    {}
  ),
  /**
   * Resolve page frontmatter from page data
   */
  resolvePageFrontmatter: (pageData) => pageData.frontmatter,
  /**
   * Merge the head config in frontmatter and site locale
   *
   * Frontmatter should take priority over site locale
   */
  resolvePageHead: (headTitle, frontmatter, siteLocale) => {
    const description = isString(frontmatter.description) ? frontmatter.description : siteLocale.description;
    const head = [
      ...Array.isArray(frontmatter.head) ? frontmatter.head : [],
      ...siteLocale.head,
      ["title", {}, headTitle],
      ["meta", { name: "description", content: description }]
    ];
    return dedupeHead(head);
  },
  /**
   * Resolve the content of page head title
   *
   * It would be used as the content of the `<title>` tag
   */
  resolvePageHeadTitle: (page, siteLocale) => [page.title, siteLocale.title].filter((item) => !!item).join(" | "),
  /**
   * Resolve page language from page data
   *
   * It would be used as the `lang` attribute of `<html>` tag
   */
  resolvePageLang: (page, siteLocale) => page.lang || siteLocale.lang || "en-US",
  /**
   * Resolve layout component of current page
   */
  resolvePageLayout: (page, layouts) => {
    let layoutName;
    if (page.path) {
      const frontmatterLayout = page.frontmatter.layout;
      if (isString(frontmatterLayout)) {
        layoutName = frontmatterLayout;
      } else {
        layoutName = LAYOUT_NAME_DEFAULT;
      }
    } else {
      layoutName = LAYOUT_NAME_NOT_FOUND;
    }
    return layouts[layoutName];
  },
  /**
   * Resolve locale path according to route path and locales config
   */
  resolveRouteLocale: (locales, routePath) => resolveLocalePath(locales, routePath),
  /**
   * Resolve site data for specific locale
   *
   * It would merge the locales fields to the root fields
   */
  resolveSiteLocaleData: (site, routeLocale) => ({
    ...site,
    ...site.locales[routeLocale],
    head: [
      // when merging head, the locales head should be placed before root head
      // to get higher priority
      ...site.locales[routeLocale]?.head ?? [],
      ...site.head ?? []
    ]
  })
});

export {
  layoutsSymbol,
  useLayouts,
  pageDataSymbol,
  usePageData,
  pageFrontmatterSymbol,
  usePageFrontmatter,
  pageHeadSymbol,
  usePageHead,
  pageHeadTitleSymbol,
  usePageHeadTitle,
  pageLangSymbol,
  usePageLang,
  pageLayoutSymbol,
  usePageLayout,
  routeLocaleSymbol,
  useRouteLocale,
  redirects,
  routes,
  resolveRoutePath,
  resolveRoute,
  useRoute,
  useRouter,
  useRedirects,
  useRoutes,
  siteData,
  useSiteData,
  siteLocaleDataSymbol,
  useSiteLocaleData,
  updateHeadSymbol,
  useUpdateHead,
  ClientOnly,
  Content,
  defineClientConfig,
  withBase,
  RouteLink,
  resolvers
};
